# Модули в ECMAScript 6: будущее уже сейчас

Эта статья в первую очередь объясняет, как работают модули в ECMAScript 6, 
следующей версии JavaScript. Также дается описание инструментов, которые 
позволяют вам использовать модули уже сейчас.

## Модульные системы для текущей версии JavaScript

Несмотря на то, что JavaScript не поддерживает модули «из коробка», сообществом 
были созданы впечатляющие решения, которые устраняют эту проблему. Два наиболее 
популярных (но, к сожалению, не совместимых) стандарта:

- CommonJS (CJS): главное воплощение этого стандарта – 
[модульная система Node.js][1] (в Node.js есть несколько фич, выходящие за 
рамки CJS). Характеристики:

    - компактный синтаксис;

    - предназначен для синхронной загрузки;

    - преимущественно используется на стороне сервера.


- Asynchronous Module Definition (AMD): наиболее популярной реализацией этого 
стандарта стал [RequireJS][2]. Характеристики:

    - синтаксис немного сложнее, что позволяет AMD работать без eval() или 
    этапа компиляции;

    - предназначен для асинхронной загрузки;

    - преимущественно используется на стороне клиента.

Все это – лишь упрощенное объяснение текущего положения вещей. Если вы хотите 
более углубленный материал, взгляните на статью 
«[Написание модульного JavaScript с помощью AMD, CommonJS и ES Harmony][3]» 
Эдди Османи (Addy Osmani).

## Модули в ECMAScript 6

Целью [модулей ECMAScript 6 (ES6)][4] было создание формата, удобного как для 
пользователей CJS, так и для пользователей AMD. В связи с этим они имеют такой 
же компактный синтаксис, как и модули CJS. С другой стороны, они не такие 
динамичные (например, вы не сможете условно загрузить модуль с помощью обычного 
синтаксиса). Это дает два основных преимущества:

- на этапе компиляции вы получите ошибки, если попытаетесь импортировать 
что-то, что не было предварительно экспортировано;

- вы можете легко осуществить асинхронную загрузку модулей ES6.

Стандарт ES6 module состоит из двух частей:

- декларативный синтаксис (для импорта и экспорта);

- API программной загрузки (чтобы задать конфигурацию загрузки модулей и для 
условной загрузки модулей).

## Синтаксис модуля ECMAScript 6

Модули ECMAScript 6 очень похожи на модули Node.js. Модуль – это просто файл 
с JavaScript кодом внутри. Для примера рассмотрим проект, файлы которого 
находятся в папке calculator/.

        calculator/
            lib/
                calc.js
            main.js

### Экспорт

Ключевое слово export, стоящее перед объявлением переменной (посредством var, 
let, const), функции или класса экспортирует их значение в остальные части 
программы.<a href="#note-1" class="reference">1</a>. В нашем примере 
calculator/lib/calc.js содержит следующий код:

        // calculator/lib/calc.js
        let notExported = 'abc';
        export function square(x) {
            return x * x;
        }
        export const MY_CONSTANT = 123;

Этот модуль экспортирует функцию square и значение MY_CONSTANT.

### Импорт

main.js, другой модуль, импортирует square с calc.js:

        // calculator/main.js
        import { square } from 'lib/calc';
        console.log(square(3));

main.js ссылается на calc.js посредством идентификатора модуля – строки 
«lib/calc». По умолчанию интерпретацией идентификатора модуля является 
относительный путь к импортируемому модулю. Обратите внимание, что, при 
необходимости, вы можете импортировать несколько значений:

        // calculator/main.js
        import { square, MY_CONSTANT } from 'lib/calc';

Либо же вы можете импортировать модуль как объект, значениями свойств которого 
будут экспортированные значения:

        // calculator/main.js
        import 'lib/calc' as c;
        console.log(c.square(3));

При неудобстве использования имен, определенных в экспортируемом модуле, вы 
можете переименовать их при импорте:

        // calculator/main.js
        import { square as squ } from 'lib/calc';
        console.log(squ(3));

### Экспорт по умолчанию

Иногда модуль экспортирует только одно значение (большой класс, например). 
В таком случае удобно определить это значение как экспортируемое по умолчанию:

        // myapp/models/Customer.js
        export default class { // анонимный класс
            constructor(id, name) {
                this.id = id;
                this.name = name;
            }
        };

Синтаксис импорта таких значений аналогичный обычному импорту без фигурных 
скобок (для простоты запоминания: вы не импортируете что-либо с модуля, а 
импортируете сам модуль):

        // myapp/myapp.js
        import Customer from 'models/Customer';
        let c = new Customer(0, 'Jane');

### Встроенные модули 

Другим вариантом использования может быть предотвращение того, чтобы переменные 
становились глобальными. На данный момент, например, для этой цели лучше всего 
использовать самовызывающуюся функцию<a href="#note-2" class="reference">2</a>:

        <script>
            (function () {  // самовызывающаяся функция
                var tmp = …;  // не станет глобальной
            }());  // close IIFE
        </script>

В ECMAScript 6 вы можете использовать анонимный внутренний модуль:

        <script>
            module {  // анонимный внутренний модуль
                let tmp = …;  // не станет глобальной
            }
        </script>

Кроме того, что такая конструкция проще с точки зрения синтаксиса, она имеет 
преимущество в виде того, что ее содержание автоматически отображается в 
strict mode<a href="#note-3" class="reference">3</a>.

Обратите внимание, что вам не обязательно находится внутри модуля для 
осуществления импорта. Инструкция import может использоваться в контексте 
обычного скрипта.

### Альтернатива встроенному экспорту

Если вы не хотите вставлять export-ы в ваш код, у вас есть возможность все 
экспортировать позже, например, в конце:

        let notExported = 'abc';
        function square(x) {
            return x * x;
        }
        const MY_CONSTANT = 123;

        export { square, MY_CONSTANT };

Также вы можете переименовывать значения во время экспорта:

        export { square as squ, MY_CONSTANT as SOME_CONSTANT };

### Осуществление реэкспорта

Вы можете реэкспортировать значения из другого модуля:

        export { encrypt as en } from 'lib/crypto';

Также вы можете реэкспортировать все:

        export * from 'lib/crypto';

## API загрузки модулей ECMAScript 6

В дополнение к декларативному синтаксису для работы с модулями, в стандарте 
также присутствует [программный API][5]. Он позволяет делать две вещи: 
программно работать с модулями и скриптами и настраивать загрузку модулей.

### Импорт модулей и загрузка скриптов

Вы можете программно импортировать модули, используя синтаксис, напоминающий AMD:

        System.import(
            ['module1', 'module2'],
            function (module1, module2) {  // успешное выполнение
                ...
            },
            function (err) {  // ошибка
                ...
            }
        );

Среди прочего, это делает возможной условную загрузку модулей.

System.load() работает аналогично с System.import(), но загружает файлы 
скриптов вместо импорта модулей.

### Настройка загрузки модулей

API загрузки модулей имеет различные хаки для настройки. Несколько примеров их 
возможностей:

- настройка отображения идентификатора модуля;

- проверка валидности модуля при импорте (к примеру, посредством KSLint или 
JSHint);

- автоматическая трансляция модулей при импорте (они могут содержать код 
CoffeeScript  или TypeScript);

- использовать существующие модули (AMD, Node.js).

Вы должны сами реализовать эти вещи, но хаки для них предусмотрены в стандарте.

## Используем модули ECMAScript 6 уже сейчас

Два самых последних проекта, делающие возможным использование модулей 
ECMAScript 6 сейчас:

- [ES6 Module Transpiler][6]: позволяет писать свои модули, используя некую 
часть стандарта ECMAScript 6 (грубо говоря, ECMAScript 5 + експорт + импорт), 
и компилирует их в модули AMD или CommonJS. [Статья][7] Райана Флоренца 
(Ryan Florence) детально объясняет этот подход.

- [ES6 Module Loader][8]: делает возможным API загрузки модулей ECMAScript 6 
в современных браузерах. Чтобы открыть для себя мир модулей, используйте API:

            System.baseURL = '/lib';
            System.import('js/test1', function (test1) {
                test1.tester();
            });

В реальных модулях вы используете ECMAScript 5 + экспорт + импорт. Например:

            export function tester() {
                console.log('hello!');
            }

Другие возможности:

- [require-hm][9]: плагин для RequireJS, позволяющий загружать модули 
ECMAScript 6 (только ECMAScript 5 + экспорт + импорт). [Статья][10] Каолана 
Макмахона (Caolan McMahon) объясняет, как он работает. Предупреждение: плагин 
использует более старый синтаксис.

- [Traceur][11] (компилятор ECMAScript 6 в ECMAScript 5): частично поддерживает 
модули, возможно, в конечном счете будет поддерживать их полностью.

- [TypeScript][12] TypeScript (грубо говоря, ECMAScript 6 и поддержка 
статической типизации): компилирует модули из внешних файлов (которые могут 
использовать большую часть ECMAScript 6) в AMD или CommonJS.

## Дополнительная литература

- Спецификация модулей ECMAScript 6: модули еще не включены в 
[черновик спецификации ECMAScript 6][13]. Пока их не включат, уточняйте детали 
в [вики-справке Harmony][14].

- «[ES6 Modules][15]», автор – Ехуда Кац (Yehuda Katz): обсуждение 
распространенных вариантов использования и совместимости с существующими 
модульными системами.

## Ссылки

<a href="#note-1" id="note-1" class="reference">1</a> [ECMAScript.next: классы][16]  
<a href="#note-1" id="note-2" class="reference">2</a> [Странности JavaScript 6: области видимости переменных][17]  
<a href="#note-1" id="note-3" class="reference">3</a> [Strict mode в Javascript: итог][18]  


[1]: http://nodejs.org/api/modules.html
[2]: http://requirejs.org/
[3]: http://addyosmani.com/writing-modular-js/
[4]: http://wiki.ecmascript.org/doku.php?id=harmony:modules
[5]: http://wiki.ecmascript.org/doku.php?id=harmony:module_loaders
[6]: https://github.com/umdjs/es6-module-transpiler
[7]: http://ryanflorence.com/2013/es6-modules-and-browser-app-delivery/
[8]: https://github.com/ModuleLoader/es6-module-loader
[9]: https://github.com/jrburke/require-hm
[10]: http://caolanmcmahon.com/posts/try_harmony_modules_today/
[11]: https://github.com/google/traceur-compiler
[12]: http://www.typescriptlang.org/
[13]: http://wiki.ecmascript.org/doku.php?id=harmony:specification_drafts
[14]: http://wiki.ecmascript.org/doku.php?id=harmony:modules
[15]: https://gist.github.com/wycats/51c96e3adcdb3a68cbc3
[16]: http://www.2ality.com/2012/07/esnext-classes.html
[17]: http://www.2ality.com/2013/05/quirk-variable-scope.html
[18]: http://www.2ality.com/2011/01/javascripts-strict-mode-summary.html
